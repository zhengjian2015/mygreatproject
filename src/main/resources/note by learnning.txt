从官网获取 配置方法
 原因  1.权威 2.避免过时性

mvn -v查看maven是否安装成功

当默认安装的 web.xml 是2.x的时候默认的 el表达式是不工作的
需要换到  3.1版本， 可以到 tomcat下的example里的web.inf 里拷贝一份已经存在的 xml文件

junit 选择 4版本起步， 因为3版本是编程，4开始是基于注解
日志  的类型 log4j,logback,common-logging
        slf4j 是规范/接口

一般选择  slf4j+ logback   // 关于加入日志的前端传过来的ip地址用户等，可以回忆下金投工作中的代码
实现 slf4j 接口并整合
<dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>

自身整合依赖
   <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>1.2.2</version>
        </dependency>

竞争是秒杀难点
技术上就是 数据的 事务和行级锁
transtion   update库存 insert 购买记录
一个在修改，很多个在等待


秒杀接口暴露 （避免用程序自动秒杀）
执行秒杀

mybatis 根据映射   对象 --- 》 数据库
参数 + sql = list

mybatis sql 可以写在xml里，也可以用注解

mybatis 如何实现dao接口 mapper自动实现dao接口
api  编程方法实现 dao接口
xml里不能有 <=  用  <![CDATA[ <= ]]>

mybatis
只写接口，不写实现

错误原因 https://www.cnblogs.com/lfm601508022/p/InvalidBoundStatement.html
xml没解析到 target里

service层是 业务逻辑层
dto 关注的是 web 和 service之间的 数据传递 
entity 是 业务数据
接口设计 应该是使用者的角度 设计

三个方面： 方法定义粒度 ，参数，返回类型（return 类型要友好/异常）

restful 一种优雅的url表诉方式
资源的状态和状态转移

POST /seckill/execute/{seckillid}

POST /seckill/{seckillld}/excetion   第2种才是友好的

GET /seckill/delete/{id}
DELETE /seckill/{id}/delete      第2种才是优雅的

GET 
POST
PUT     put和post没明显区别，put可能用于幂等性
DELETE 

springmvc 运行流程
1. 用户发送请求 都到 dispatcherServlet 
2.会到 DefaultAnnotaion HandlerMapping  （url对应到handler)
3.接着会到 DefaultAnnotaion HandlerAdapter (handler适配，4 到controller,如果有拦截器也会衔接)
5.返回到 modelandview
6.通过dispathcherServlet 到 InternalResoureViewResolver  结合Model 返回jsp


applicationContext-*.xml 可以映射多个xml文件

Controller 里的 method设置为post安全点
post 可以预防， 直接在url里输入地址获取数据
 

https://zhidao.baidu.com/question/1447368474883103140.html
理论上来说js标签放在html文档的任何位置都可以，规范起见，推荐放到body结束标签的末尾，包含到body标签内：
<body>
    <!-- 这里是其他的HTML标签 -->
    <script> // 这里是代码 </script>
</body>
这样处理的好处是无需担心因页面未完成加载，造成DOM节点获取不到，使脚本报错的问题，而且能避免因脚本运行缓慢造成页面卡死的问题。另外，Yahoo的前端优化指南里就有这一条。


cdn 内容分发网络  视频资源也是放在cdn 上
部署在离用户最近的 网络节点上
命中cdn不需要访问后端服务器
互联网公司自己搭建cdn或租用

获取系统时间 不需要优化  java访问内存只需 10 纳秒

秒杀地址接口分析
可以用redis 缓存
一致性维护地址， 超时redis

秒杀操作优化分析
无法使用cdn 缓存
一行数据竞争 热点竞争


原子技术器  -> redis/nosql
记录行为  ->  分布式mq
消费消息并落地 -> mysql

优点 ： 能扛住很高并发
缺点 : 运维成本和稳定型 :nosql mq
开发成本 数据一致性
幂等性难保证 重复秒杀问题
不适合新手的架构

mysql其实并不低效  一条update  约1s执行4w次

mysql低效在  行级锁 ，当一条减库存时， 另一个人在等行锁，直到第一个人commit，后面才获得锁

瓶颈分析
update 减库存    网络延迟 GC
insert  购买明细  网络延迟 GC
commit/rollback

把 这操作 放到 mysql 服务端
两种解决方案
  定制sql方案 修改mysql源码
  二使用存储过程  整个事务在mysql端完成

spring transtation等是放在客户端的
在行级锁没有那么高的竞争下是完全没问题
秒杀是个特殊的需求

方案
前端 防重复提交
cdn缓存 后端缓存
减少事务锁时间（存过）


存进redis缓存时 要把java对象序列化
由于是 高并发要把考虑极致
所以要 选择序列化 效率最高的
